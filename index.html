<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>VÃ²ng Quay May Máº¯n</title>
  <link rel="stylesheet" href="style.css" />
  <!-- config.js pháº£i load TRÆ¯á»šC index logic -->
  <script src="config.js"></script>
</head>
<body>

<!-- â”€â”€ Confetti canvas (náº±m dÆ°á»›i cÃ¹ng Ä‘á»ƒ khÃ´ng block click) â”€â”€ -->
<canvas id="confettiCanvas"></canvas>

<div id="app">

  <!-- Header -->
  <header class="header">
    <h1 id="mainTitle"></h1>
    <p class="subtitle" id="mainSubtitle"></p>
  </header>

  <!-- Wheel -->
  <section class="wheel-section">
    <div class="wheel-container" id="wheelContainer">
      <div class="tick-indicator"></div>
      <canvas id="wheelCanvas"></canvas>
      <div class="pointer"></div>
      <div class="hub" id="hubBtn" title="Nháº¥n Ä‘á»ƒ quay">ğŸ¯</div>
    </div>

    <button class="spin-btn" id="spinBtn">
      <span id="spinBtnIcon"></span>
      <span id="spinBtnText"></span>
    </button>
  </section>

  <!-- Lá»‹ch sá»­ káº¿t quáº£ -->
  <section class="history-section" id="historySection" style="display:none">
    <p class="history-title">Káº¿t quáº£ gáº§n Ä‘Ã¢y</p>
    <div class="history-list" id="historyList"></div>
  </section>

</div>

<!-- Result Popup -->
<div class="popup-overlay" id="popupOverlay">
  <div class="popup-card">
    <div id="popupVisual"></div>
    <div class="popup-label" id="popupLabel"></div>
    <p class="popup-message" id="popupMessage"></p>
    <button class="popup-close-btn" id="popupCloseBtn"></button>
  </div>
</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   LUCKY WHEEL ENGINE â€” index.html (inline JS)
   Äá»c dá»¯ liá»‡u tá»« WHEEL_CONFIG (config.js)
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

(function () {
  "use strict";

  /* â”€â”€ Aliases â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const C = WHEEL_CONFIG;
  const $ = id => document.getElementById(id);

  /* â”€â”€ Apply theme CSS vars â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const root = document.documentElement;
  if (C.theme) {
    if (C.theme.background)   document.body.style.background = C.theme.background;
    if (C.theme.accentColor)  root.style.setProperty('--accent', C.theme.accentColor);
    if (C.theme.glowColor)    root.style.setProperty('--glow', C.theme.glowColor);
    if (C.theme.fontFamily) {
      root.style.setProperty('--font', C.theme.fontFamily);
      document.body.style.fontFamily = C.theme.fontFamily;
    }
  }

  /* â”€â”€ Apply text from config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  $('mainTitle').textContent        = C.title    || 'VÃ²ng Quay May Máº¯n';
  $('mainSubtitle').textContent     = C.subtitle || '';
  $('spinBtnIcon').textContent      = (C.spinButtonIcon || '') + ' ';
  $('spinBtnText').textContent      = C.spinButtonText || 'QUAY NGAY';
  $('popupCloseBtn').textContent    = C.popup?.closeButtonText || 'Nháº­n ThÆ°á»Ÿng ğŸ';

  /* â”€â”€ Build weighted segment pool â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  // Chá»‰ nhá»¯ng segment cÃ³ weight > 0 má»›i Ä‘Æ°á»£c rÃºt thÄƒm
  const validSegments = C.segments.filter(s => (s.weight || 0) > 0);
  const totalWeight   = validSegments.reduce((a, s) => a + s.weight, 0);

  function pickWinner() {
    let r = Math.random() * totalWeight;
    for (const seg of validSegments) {
      r -= seg.weight;
      if (r <= 0) return seg;
    }
    return validSegments[validSegments.length - 1];
  }

  /* â”€â”€ Canvas setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const canvas  = $('wheelCanvas');
  const ctx     = canvas.getContext('2d');
  const SIZE    = 680; // internal resolution
  canvas.width  = SIZE;
  canvas.height = SIZE;
  const R = SIZE / 2;

  const SEGS     = C.segments;
  const N        = SEGS.length;
  const ARC      = (2 * Math.PI) / N;

  /* Pre-load images */
  const imgCache = {};
  SEGS.forEach(seg => {
    if (seg.image) {
      const img = new Image();
      img.src = seg.image;
      img.onload = () => { imgCache[seg.id] = img; drawWheel(currentAngle); };
      imgCache[seg.id] = img;
    }
  });

  /* â”€â”€ Draw â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  let currentAngle = -Math.PI / 2; // start so first segment top-center

  function drawWheel(rotation) {
    ctx.clearRect(0, 0, SIZE, SIZE);
    ctx.save();
    ctx.translate(R, R);
    ctx.rotate(rotation);

    SEGS.forEach((seg, i) => {
      const start = i * ARC;
      const end   = start + ARC;
      const mid   = start + ARC / 2;

      // Segment fill
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, R - 4, start, end);
      ctx.closePath();
      ctx.fillStyle = seg.color || '#888';
      ctx.fill();

      // Segment border
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, R - 4, start, end);
      ctx.closePath();
      ctx.strokeStyle = 'rgba(255,255,255,0.18)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Decorative outer arc highlight
      ctx.beginPath();
      ctx.arc(0, 0, R - 4, start, end);
      ctx.strokeStyle = 'rgba(255,255,255,0.35)';
      ctx.lineWidth = 4;
      ctx.stroke();

      // Text / image
      ctx.save();
      ctx.rotate(mid);

      const textR  = R * 0.62;
      const imgSeg = imgCache[seg.id];

      if (imgSeg && imgSeg.complete && imgSeg.naturalWidth) {
        // Draw image
        const imgSize = R * 0.22;
        ctx.drawImage(imgSeg, textR - imgSize / 2, -imgSize / 2, imgSize, imgSize);
        // Label below image
        ctx.translate(textR + imgSize * 0.7, 0);
      } else {
        // Emoji
        if (seg.emoji) {
          ctx.font = `${R * 0.1}px serif`;
          ctx.textAlign    = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(seg.emoji, textR - R * 0.07, -R * 0.06);
        }
        ctx.translate(textR + R * 0.04, 0);
      }

      // Main label
      ctx.textAlign    = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle    = seg.textColor || '#fff';

      const fontSize = Math.max(14, Math.min(28, R * 0.09));
      ctx.font = `900 ${fontSize}px ${C.theme?.fontFamily || 'Baloo 2, sans-serif'}`;
      ctx.shadowColor  = 'rgba(0,0,0,0.5)';
      ctx.shadowBlur   = 4;
      ctx.fillText(seg.label || '', 0, seg.sublabel ? -fontSize * 0.6 : 0);

      // Sublabel
      if (seg.sublabel) {
        const subSize = Math.max(10, fontSize * 0.6);
        ctx.font = `600 ${subSize}px ${C.theme?.fontFamily || 'Baloo 2, sans-serif'}`;
        ctx.fillStyle = seg.textColor ? seg.textColor + 'cc' : 'rgba(255,255,255,0.8)';
        ctx.fillText(seg.sublabel, 0, fontSize * 0.7);
      }

      ctx.restore();
    });

    // Center hole
    ctx.beginPath();
    ctx.arc(0, 0, R * 0.09, 0, Math.PI * 2);
    ctx.fillStyle   = '#1a0a2e';
    ctx.fill();
    ctx.strokeStyle = 'rgba(255,215,0,0.6)';
    ctx.lineWidth   = 3;
    ctx.stroke();

    ctx.restore();
  }

  drawWheel(currentAngle);

  /* â”€â”€ Spin logic â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  let isSpinning = false;
  let spinStart, spinDuration, spinExtra, winner, spinStartAngle;
  let audioSpin, audioWin;

  if (C.soundSpin) { audioSpin = new Audio(C.soundSpin); audioSpin.loop = true; }
  if (C.soundWin)  { audioWin  = new Audio(C.soundWin); }

  function startSpin() {
    if (isSpinning || validSegments.length === 0) return;

    winner = pickWinner();

    // Calculate target angle: align winner segment to pointer (right side, 0Â°)
    const winnerIndex  = SEGS.indexOf(winner);
    // pointer is at RIGHT side (0Â°), wheel starts at -Ï€/2
    // We want the center of winner segment to face right = 0Â°
    const segCenter    = winnerIndex * ARC + ARC / 2;
    // Current normalized angle
    const norm         = ((currentAngle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
    // Target rotation (pointer at right = 0, so we want -segCenter at 0 after rotation)
    const targetNorm   = (2 * Math.PI - segCenter) % (2 * Math.PI);
    let   delta        = (targetNorm - norm + 2 * Math.PI) % (2 * Math.PI);
    if (delta < 0.01) delta += 2 * Math.PI;

    const minRotations = (C.minSpins || 5) * 2 * Math.PI;
    spinExtra          = minRotations + delta;
    spinDuration       = C.spinDuration || 5000;
    spinStartAngle     = currentAngle;
    spinStart          = null;

    isSpinning = true;
    $('spinBtn').disabled = true;
    $('hubBtn').style.pointerEvents = 'none';

    if (audioSpin) { audioSpin.currentTime = 0; audioSpin.play().catch(()=>{}); }

    requestAnimationFrame(animateSpin);
  }

  function easeOut(t) {
    // Smooth deceleration
    return 1 - Math.pow(1 - t, 4);
  }

  function animateSpin(timestamp) {
    if (!spinStart) spinStart = timestamp;
    const elapsed  = timestamp - spinStart;
    const progress = Math.min(elapsed / spinDuration, 1);
    const eased    = easeOut(progress);

    currentAngle = spinStartAngle + spinExtra * eased;
    drawWheel(currentAngle);

    if (progress < 1) {
      requestAnimationFrame(animateSpin);
    } else {
      finishSpin();
    }
  }

  function finishSpin() {
    isSpinning = false;
    $('spinBtn').disabled = false;
    $('hubBtn').style.pointerEvents = '';

    if (audioSpin) audioSpin.pause();
    if (audioWin)  { audioWin.currentTime = 0; audioWin.play().catch(()=>{}); }

    addHistory(winner);
    showPopup(winner);
  }

  /* â”€â”€ History â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const MAX_HISTORY = 8;
  const historyData = [];

  function addHistory(seg) {
    historyData.unshift(seg);
    if (historyData.length > MAX_HISTORY) historyData.pop();
    renderHistory();
  }

  function renderHistory() {
    const section = $('historySection');
    const list    = $('historyList');
    section.style.display = '';
    list.innerHTML = '';
    historyData.forEach(seg => {
      const el = document.createElement('span');
      el.className = 'history-item';
      el.style.borderColor = seg.color + '80';
      el.style.color = '#fff';
      el.textContent = (seg.emoji || '') + ' ' + seg.label;
      list.appendChild(el);
    });
  }

  /* â”€â”€ Popup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  function showPopup(seg) {
    const visual  = $('popupVisual');
    const imgSeg  = imgCache[seg.id];

    if (imgSeg && imgSeg.complete && imgSeg.naturalWidth) {
      visual.innerHTML = `<img class="popup-reward-image" src="${seg.image}" alt="${seg.label}" />`;
    } else {
      visual.innerHTML = `<div class="popup-emoji">${seg.emoji || 'ğŸ'}</div>`;
    }

    $('popupLabel').textContent   = seg.label || '';
    $('popupMessage').textContent = seg.message || 'ğŸ‰ ChÃºc má»«ng!';

    $('popupOverlay').classList.add('active');

    if (C.popup?.showConfetti) launchConfetti();

    // Auto-close
    if (C.popup?.autoCloseAfter > 0) {
      setTimeout(closePopup, C.popup.autoCloseAfter);
    }
  }

  function closePopup() {
    $('popupOverlay').classList.remove('active');
    stopConfetti();
  }

  $('popupCloseBtn').addEventListener('click', closePopup);
  $('popupOverlay').addEventListener('click', e => {
    if (e.target === $('popupOverlay')) closePopup();
  });

  /* â”€â”€ Spin triggers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  $('spinBtn').addEventListener('click', startSpin);
  $('hubBtn').addEventListener('click', startSpin);

  /* â”€â”€ Confetti â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  const confCanvas = $('confettiCanvas');
  const confCtx    = confCanvas.getContext('2d');
  let   confParts  = [];
  let   confAnim   = null;
  let   confActive = false;

  function resizeConf() {
    confCanvas.width  = window.innerWidth;
    confCanvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeConf);
  resizeConf();

  function launchConfetti() {
    confActive = true;
    confParts  = Array.from({ length: 120 }, () => ({
      x: Math.random() * confCanvas.width,
      y: confCanvas.height * Math.random() * -0.3 - 20,
      vx: (Math.random() - 0.5) * 5,
      vy: Math.random() * 4 + 2,
      size: Math.random() * 9 + 5,
      color: ['#FFD700','#FF6B6B','#6BCB77','#4D96FF','#C77DFF','#FFB347','#fff'][Math.floor(Math.random()*7)],
      rot: Math.random() * 360,
      rotV: (Math.random() - 0.5) * 8,
      shape: Math.random() < 0.5 ? 'rect' : 'circle',
    }));
    if (confAnim) cancelAnimationFrame(confAnim);
    animateConf();
  }

  function animateConf() {
    if (!confActive) return;
    confCtx.clearRect(0, 0, confCanvas.width, confCanvas.height);
    confParts.forEach(p => {
      p.x   += p.vx;
      p.y   += p.vy;
      p.vy  += 0.1;
      p.rot += p.rotV;
      confCtx.save();
      confCtx.translate(p.x, p.y);
      confCtx.rotate(p.rot * Math.PI / 180);
      confCtx.fillStyle = p.color;
      if (p.shape === 'rect') {
        confCtx.fillRect(-p.size / 2, -p.size / 4, p.size, p.size / 2);
      } else {
        confCtx.beginPath();
        confCtx.arc(0, 0, p.size / 2, 0, Math.PI * 2);
        confCtx.fill();
      }
      confCtx.restore();
    });
    confParts = confParts.filter(p => p.y < confCanvas.height + 30);
    if (confParts.length > 0) {
      confAnim = requestAnimationFrame(animateConf);
    } else {
      stopConfetti();
    }
  }

  function stopConfetti() {
    confActive = false;
    if (confAnim) cancelAnimationFrame(confAnim);
    confCtx.clearRect(0, 0, confCanvas.width, confCanvas.height);
  }

})();
</script>
</body>
</html>